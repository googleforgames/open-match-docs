---
title: "Open Match Internals"
linkTitle: "Open Match Internals"
weight: 2
description:
  This document provides internal details of Open Match core components.
---

## Concepts

- _Tickets_: a basic matchmaking entity in Open Match that could be used to represent an individual  or players in a group.
- _Assignment_: an object represents the game server that a ticket binds with.
- _Filter_: an object used to query tickets that meets certain filtering criteria.
- _Pool_: an object consists of different filters and an unique ID.
- _Roster_: a named collection of ticket IDs. It is used to represent a team/substeam in a match.
- _MatchProfile_: an object that defines the shape of a match.
- _Match_: an object abstraction of an actual match.
- _Frontend_: a service that manages tickets in open-match.
- _Backend_: a service that generats matches and host assignments in open-match.
- _Mmlogic_: a gateway service that supports data querying in open-match.
- _Matchfunction_: a service where your custom match making logic lives in.

## Online Game Architecture

![Online Game Architecture](../../../images/online_game_arch.jpeg)

To understand the usage scenario for Open Match, here is a reference architecture for Online Game Services. At a high level, here is an overview of the components that Open Match assumes are present for an online Game Service:

- _Game Frontend_: The endpoint that the Game Clients connect to. Game Frontend can fetch and validate player data from Game Platform services (XBOX, Playstation).
- _Director_: The Game Backend component that requests for matches, fetches Game Server allocations and assigns them to the Tickets.
- _GameServers_: The Game Servers that hosts the Game sessions to which the Game Clients connect.
- _MatchFunction_: Customizable  function that generates  Match proposals.
- _Evaluator_: The customizable logic that evaluates proposals and returns accepted Matches.

## Open Match Architecture

![Open Match Architecture](../../../images/open_match_arch.jpeg)

### Frontend

Open Match Frontend is the service that enables Ticket management. The Game Frontend communicates with Open Match Frontend to create Tickets, fetch Ticket assignments etc. When a Ticket is created, the Frontend adds it to Open Match State Storage, indexing the Ticket properties. The Frontend also enables setting up a watch on a Ticket Assignments, providing streaming updates as the Ticket Assignment changes.

### Backend

Open Match Backend is the service that enables requesting a Match, setting Assignment to Ticket etc. The Director communicates with Open Match Backend to generate Matches, set Assignments. The Backend triggers MMF execution which generates Match proposals. It passes these proposals to the Synchronizer to have them evaluated and returns the results to the Director. The Director calls into the Backend to set Assignment on Tickets

### MMLogic

MMLogic acts as a data layer providing the ability to query Tickets pool using a set of Filters. A Match function typically uses the MMLogic API to fetch players belonging to a Pool to then generate matches. 

### Synchronizer

A common usage pattern supported by Open Match is to allow multiple MMFs to execute concurrently, allowing for the same Pool to be evaluated for multiple Match profiles.
This could generate potentially overlapping proposals that need to be ‘Evaluated’ (decolided, compared for quality) before promoting to results. Concurrent proposals across multiple Backend instances need to be aggregated before evaluating. Also, when evaluating, none of the Backend instances should be permitted to trigger new MMFs to avoid reusing Tickets being evaluated. Synchronizer is an internal Open Match component that runs as a singleton, aggregates proposals generated by multiple Backend instances and triggers their Evaluation, while blocking new MMF execution till evaluation results have been processed.

![Synchronization Cycle](../../../images/sync_cycle.jpeg)

Synchronizer is implemented as a state machine with the above states. 

- A Backend Registers a FetchMatch call before triggering Match Functions.
- Once the proposals are ready, it calls Evaluate on the Synchronizer to get results.
- A Synchronizer enters into a ‘Context Registration’ phase when it receives a first ‘Register’ call and stays in this state for a configurable time window.
- After this, it moves to ‘Proposal Acceptance’ state waiting for any proposals to be submitted for evaluation. Any new registration requests are blocked till evaluation is complete.
- ‘Evaluate’ call queues proposals for a registered request for evaluation and blocks till the end of the window till Evaluation happens.
- The Synchronizer then moves to ‘Evaluation’ state and triggers the Evaluator, fetches results and unblocks waiting ‘Evaluate’ calls and then resets state machine unblocking new registrations.

### Match Function

Match Function is implemented as a gRPC / HTTP service by the game developer. The details of the Match Function to invoke are passed in by the Director in the FetchMatches call to the Open Match Backend. While processing the FetchMatches call, the Backend invokes a match function per Match Profile passed in the call. The Match Function returns one or more Match proposals to the Backend.

### Evaluator

Evaluator is a user customized component implemented as a gRPC / HTTP service. Synchronizer calls the evaluator at the end of each synchronization cycle with a list of Match proposals to be evaluated. The Evaluator decollides these proposals, evaluates them for quality and returns a list of Matches to be returned as results.

## E2E Matchmaking flow (Internal Details)

Here is the E2E flow to generate match results, providing details of interactions between internal Open Match components: 

1. Game Frontend creates a Ticket for a Player / Group, adding it to matchmaking pool.
2. Frontend stores that Ticket in state storage, indexing the Ticket for configured property indices.
3. The Game Fontend can get the Ticket to fetch Assignment or can request for streaming updates to Ticket Assignment.
4. Director calls FetchMatches on the Backend with a set of profiles specifying the Match Function to be triggered.
5. Backend Registers this call with the synchronizer.
6. Backend triggers MMF runs for the Match Profiles that return proposals.
7. Backend aggregates the proposals and submits proposals to Synchronizer for evaluation.
8. Synchronizer blocks all Backend calls till end of synchronization window and then triggers the Evaluator with all the aggregated proposals.
9. The Evaluator receives proposals and returns results.
10. Synchronizer returns the results to the respective pending Backend calls.
11. Backend returns the results for FetchMatches.
12. The Director then requests for DGS allocation for the Match.
13. Director calls AssignTickets to set DGS Assignments on Tickets.
14. As Ticket Assignment changes, the changes are streamed back to the requestor via the Open Match Frontend.
