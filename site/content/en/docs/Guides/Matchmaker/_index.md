---
title: "Guide to Matchmaking using Open Match"
linkTitle: "Matchmaking using Open Match"
weight: 1
description: >
  A deep dive into building an Open Match based Matchmaker.
---

This section is work in progress. Please revisit later.

## Objectives

This guide explains the core Open Match concepts you need to understand to build your Open Match based Matchmaker. The guide presents the key components of an Online Game Services architecture, their responsibilities and their interactions with core Open Match Services. The guide also explains in details, the customizations to be added to Open Match.

## Game Services Architecure

Here is a high level overview of an online Game Services architecture with details of which Open Match Core services do the different components interact with:

![Life of a Match](../../../images/architecture_omdetails.jpg)

### Open Match Services

Open Match compriese of a set of services hoseted in a Kubernetes cluster. The core functionality of Open Match is exposed as the following services:

#### Open Match Frontend Service

The Open Match Frontend primarily provides management of Tickets, a basic matchmaking entity in Open Match. It is used to create, delete and get details of the current state of a Ticket. In a typical setup, the Game Frontned will interact with Open Match Frontend to manage the current matchmaking pool.

#### Open Match Backend Service

The Open Match Backend is used to Fetch Matches and set Assignments for Matches. Typically, the Game Backend (aka the Director) interacts with Open Match Backend.

#### MMLogic Service (Data Access)

The MMLogic service presents the ability to query for Tickets in Open Match. The Match Function that has the core matchmaking logic typically interfaces with the MMLogic API to query the matchmaking pool for Tickets that satisfy certain constraints.

### Core Customizations

Open Match needs the user to author some key components to customize Open Match for the specific matchmaking use case. Here are the core customizations that an Open Match user needs to build:

#### Match Function

The core matchmaking logic is provided to Open Match as a Match Function. At a high level, the match function accepts a Match Profile, queries for the Tickets matching certain constraints and generates match proposals. A Match Function is triggered in response to a request to generate Matches.

#### Evaluator

Open Match allows for concurrent Match Functions to execute on the same player pool to generate Match proposals. Thus the proposals generated by concurrent Match Function executions may have overlapping results. Open Match allows the user to plug in an Evaluator component that accesses concurrently generated match proposals and deduplicates them.

### External Components

Here are the external components that the described matchmaking flow assumes to be present in the Online Game Service architecture that uses an Open Match based matchmaker:

- _GameClient_: The actual client (eg. Console) where the request to play a Match originates.
- _GameFrontend_: The service(s) that accepts the request, validates player data etc. and understand game specific requirements for matchmaking (group, backfill)
- _PlatformServices_: Services offered by First Party Platforms (Xbox, PS) that the Game Frontend may need to integrate with.
- _Director_: The Game Backend that can request Open Match for a match and set assignments to Tickets (This could be one or more services and Open Match itself is not authoritative about the details here)
- _GameServers_: The Game Servers hosting the game, which need to be allocated to Tickets during matchmaking.

### Matchmaking flow

1. A Game Client connects to the Game Frontend requesting for a Game Server assignment.
2. The Game Frontend validates the player, fetches its properties from the platform services and calls Open Match Frontend to create a Ticket for this player.
3. After successful Ticket creation, the GameFrontend requests Open Match Frontend to watch the Ticket and stream any Assignment changes back.
4. The Director calls FetchMatches on Open Match Backend to generate Matches for a Match Profile providing details of the Match Function to invoke.
5. Open Match Backend triggers concurrent Match Function executions (one match function call per Match Profile).
6. The Match Function fetches all the Tickets from the Ticket Pools in the Match Profile and generates Match proposals.
7. The Open Match Backend requests the Synchronizer to Evaluate these Proposals.
8. The Synchronizer triggers the Evaluation at the end of a Synchronization cycle.
9. The Evaluator decolides, compares all proposals submitted and returns results.
10. The Open Match Backend returns the FetchMatches results back to the Director.
11. The Director requests the Game Backend for a Game Server allocation for this Match.
12. The Director then sets an Assignment for all the Tickets in the Match to the Game Server that was returned.
13. The Open Match Frontend returns the Assignment set on this Ticket to the GetAssignments call from the Game Frontend that was waiting for assignments.

## Components Deep Dive

{{< pagelist >}}
